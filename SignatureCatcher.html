<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>智能签名提取器 (Web版)</title>
     
    <!-- 1. 引入样式库 (Tailwind) -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', '-apple-system', 'BlinkMacSystemFont', 'Segoe UI', 'Roboto', 'sans-serif'],
                    },
                    animation: {
                        'fade-in': 'fadeIn 0.2s ease-in-out',
                    },
                    keyframes: {
                        fadeIn: {
                            '0%': { opacity: '0', transform: 'scale(0.95)' },
                            '100%': { opacity: '1', transform: 'scale(1)' },
                        }
                    }
                }
            }
        }
    </script>
 
    <!-- 2. 引入字体 -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
 
    <!-- 3. 引入 React 和核心库 -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <!-- Babel 用于在浏览器中直接编译 JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- JSZip 用于打包下载 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
 
    <style>
      body {
        font-family: 'Inter', sans-serif;
        background-color: #E0E5EC;
        color: #1d1d1f;
        -webkit-font-smoothing: antialiased;
        overflow: hidden;
        margin: 0;
        padding: 0;
      }
      .mesh-bg {
        position: fixed;
        top: 0; left: 0; width: 100vw; height: 100vh;
        z-index: -1;
        background: #d4dceb;
      }
      .mesh-bg::before {
        content: '';
        position: absolute;
        top: -50%; left: -50%; width: 200%; height: 200%;
        background: 
          radial-gradient(circle at 50% 50%, rgba(142, 197, 252, 0.4), transparent 50%),
          radial-gradient(circle at 10% 20%, rgba(224, 195, 252, 0.4), transparent 40%),
          radial-gradient(circle at 90% 80%, rgba(166, 169, 240, 0.4), transparent 40%);
        filter: blur(80px);
        animation: moveBackground 20s ease-in-out infinite alternate;
      }
      @keyframes moveBackground {
        0% { transform: translate(0, 0); }
        100% { transform: translate(-10%, -10%); }
      }
      .no-scrollbar::-webkit-scrollbar { display: none; }
      .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
      ::-webkit-scrollbar { width: 6px; }
      ::-webkit-scrollbar-track { background: transparent; }
      ::-webkit-scrollbar-thumb { background: rgba(0, 0, 0, 0.1); border-radius: 10px; }
      ::-webkit-scrollbar-thumb:hover { background: rgba(0, 0, 0, 0.2); }
      .cursor-crosshair { cursor: crosshair; }
      .cursor-grab { cursor: grab; }
      .cursor-grabbing { cursor: grabbing; }
      /* 颜色选择器样式覆盖 */
      input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
      input[type="color"]::-webkit-color-swatch { border: none; border-radius: 50%; }
    </style>
</head>
<body>
    <div class="mesh-bg"></div>
    <div id="root"></div>
 
    <script type="text/babel">
        // --- 0. 全局变量与工具 ---
        const { useState, useRef, useEffect, useCallback } = React;
 
        // --- 1. 图标组件 (Icons) ---
        const UploadIcon = ({ className }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" /><polyline points="17 8 12 3 7 8" /><line x1="12" y1="3" x2="12" y2="15" /></svg>
        );
        const ScissorIcon = ({ className }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><circle cx="6" cy="6" r="3" /><circle cx="6" cy="18" r="3" /><line x1="20" y1="4" x2="8.12" y2="15.88" /><line x1="14.47" y1="14.48" x2="20" y2="20" /><line x1="8.12" y1="8.12" x2="12" y2="12" /></svg>
        );
        const DownloadIcon = ({ className }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" /><polyline points="7 10 12 15 17 10" /><line x1="12" y1="15" x2="12" y2="3" /></svg>
        );
        const XIcon = ({ className }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><line x1="18" y1="6" x2="6" y2="18" /><line x1="6" y1="6" x2="18" y2="18" /></svg>
        );
        const UndoIcon = ({ className }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M3 7v6h6" /><path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13" /></svg>
        );
        const SettingsIcon = ({ className }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.09a2 2 0 0 1-1-1.74v-.47a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.35a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z" /><circle cx="12" cy="12" r="3" /></svg>
        );
        const SparklesIcon = ({ className }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275 1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L21 12l-5.813-1.912a2 2 0 0 1-1.275-1.275L12 3Z" /></svg>
        );
        const LoaderIcon = ({ className }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={`animate-spin ${className}`}><path d="M21 12a9 9 0 1 1-6.219-8.56" /></svg>
        );
        const ZoomInIcon = ({ className }) => (
             <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><circle cx="11" cy="11" r="8" /><line x1="21" y1="21" x2="16.65" y2="16.65" /><line x1="11" y1="8" x2="11" y2="14" /><line x1="8" y1="11" x2="14" y2="11" /></svg>
        );
        const ZoomOutIcon = ({ className }) => (
             <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><circle cx="11" cy="11" r="8" /><line x1="21" y1="21" x2="16.65" y2="16.65" /><line x1="8" y1="11" x2="14" y2="11" /></svg>
        );
        const ResetIcon = ({ className }) => (
             <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8" /><path d="M3 3v5h5" /></svg>
        );
        const HandIcon = ({ className }) => (
             <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M18 11V6a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v0" /><path d="M14 10V4a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v2" /><path d="M10 10.5V6a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v8" /><path d="M18 8a2 2 0 1 1 4 0v6a8 8 0 0 1-8 8h-2c-2.8 0-4.5-.86-5.99-2.34l-3.6-3.6a2 2 0 0 1 2.83-2.82L7 15" /></svg>
        );
        const MaximizeIcon = ({ className }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><polyline points="15 3 21 3 21 9" /><polyline points="9 21 3 21 3 15" /><line x1="21" y1="3" x2="14" y2="10" /><line x1="3" y1="21" x2="10" y2="14" /></svg>
        );
        const WandIcon = ({ className }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M15 4V2" /><path d="M15 16v-2" /><path d="M8 9h2" /><path d="M20 9h2" /><path d="M17.8 11.8 19 13" /><path d="M15 9h0" /><path d="M17.8 6.2 19 5" /><path d="m3 21 9-9" /><path d="M12.2 6.2 11 5" /></svg>
        );
        const EyeIcon = ({ className }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z" /><circle cx="12" cy="12" r="3" /></svg>
        );
        const PaletteIcon = ({ className }) => (
             <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><circle cx="13.5" cy="6.5" r=".5" fill="currentColor"/><circle cx="17.5" cy="10.5" r=".5" fill="currentColor"/><circle cx="8.5" cy="7.5" r=".5" fill="currentColor"/><circle cx="6.5" cy="12.5" r=".5" fill="currentColor"/><path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10c.926 0 1.648-.746 1.648-1.688 0-.437-.18-.835-.437-1.125-.29-.289-.438-.652-.438-1.125a1.64 1.64 0 0 1 1.668-1.668h1.996c3.051 0 5.555-2.503 5.555-5.554C21.965 6.012 17.461 2 12 2z"/></svg>
        );
 
        // --- 2. 图像处理工具函数 (Image Utils) ---
        const loadImage = (src) => {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = "Anonymous";
                img.onload = () => resolve(img);
                img.onerror = (e) => reject(e);
                img.src = src;
            });
        };
 
        // 改变签名颜色
        const applySignatureColor = async (imgUrl, color) => {
            const img = await loadImage(imgUrl);
            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext('2d');
 
            // 1. 绘制原始签名
            ctx.drawImage(img, 0, 0);
 
            // 2. 使用 'source-in' 混合模式
            // 这会保留 Canvas 上已有的不透明度（Alpha），但将颜色替换为 fillStyle 的颜色
            ctx.globalCompositeOperation = 'source-in';
            ctx.fillStyle = color;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
 
            return canvas.toDataURL('image/png');
        };
 
        // 图像处理滤镜
        const applyImageFilters = async (imgObj, type) => {
            const canvas = document.createElement('canvas');
            canvas.width = imgObj.naturalWidth;
            canvas.height = imgObj.naturalHeight;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(imgObj, 0, 0);
             
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const width = canvas.width;
            const height = canvas.height;
 
            if (type === 'bleach') {
                // 升级版算法：局部自适应阈值 (Local Adaptive Thresholding) - 类似 Sauvola 算法
                // 解决阴影和光照不均的核心思路：不使用全局固定值，而是计算每个像素周边的平均亮度
                // 优化：使用积分图 (Integral Image) 将计算复杂度从 O(N*r^2) 降低到 O(N)
                 
                // 1. 转换为灰度
                const grayData = new Uint8Array(width * height);
                for (let i = 0; i < data.length; i += 4) {
                    // 使用亮度公式
                    grayData[i / 4] = 0.299 * data[i] + 0.587 * data[i+1] + 0.114 * data[i+2];
                }
 
                // 2. 构建积分图 (Integral Image)
                // integral[y][x] 存储从 (0,0) 到 (x,y) 的像素和
                const integral = new Uint32Array(width * height);
                 
                for (let y = 0; y < height; y++) {
                    let sum = 0;
                    for (let x = 0; x < width; x++) {
                        sum += grayData[y * width + x];
                        if (y === 0) {
                            integral[y * width + x] = sum;
                        } else {
                            integral[y * width + x] = integral[(y - 1) * width + x] + sum;
                        }
                    }
                }
 
                // 3. 应用局部自适应阈值
                const radius = Math.floor(Math.max(width, height) / 80); // 动态半径，例如1000px宽图用12px半径
                const sensitivity = 0.15; // 敏感度，值越大，对比度要求越高，背景越干净
 
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        // 计算窗口边界
                        const x1 = Math.max(0, x - radius);
                        const x2 = Math.min(width - 1, x + radius);
                        const y1 = Math.max(0, y - radius);
                        const y2 = Math.min(height - 1, y + radius);
                        const count = (x2 - x1 + 1) * (y2 - y1 + 1);
 
                        // 利用积分图O(1)快速计算局部和
                        // Sum = D + A - B - C
                        let sum = integral[y2 * width + x2];
                        if (y1 > 0) sum -= integral[(y1 - 1) * width + x2];
                        if (x1 > 0) sum -= integral[y2 * width + (x1 - 1)];
                        if (y1 > 0 && x1 > 0) sum += integral[(y1 - 1) * width + (x1 - 1)];
                         
                        const mean = sum / count;
                         
                        // 核心判断：如果当前像素显著低于周围平均值(mean * (1-sensitivity))，则是字，否则是背景
                        const currentPixel = grayData[y * width + x];
                        const idx = (y * width + x) * 4;
 
                        // 黑色：当前像素 < 局部平均值 * 0.85
                        if (currentPixel < mean * (1 - sensitivity)) {
                            // 保留笔迹，并稍微加深
                            data[idx] = Math.max(0, currentPixel - 30);
                            data[idx+1] = Math.max(0, currentPixel - 30);
                            data[idx+2] = Math.max(0, currentPixel - 30);
                        } else {
                            // 漂白背景
                            data[idx] = 255;
                            data[idx+1] = 255;
                            data[idx+2] = 255;
                        }
                    }
                }
 
            } else if (type === 'sharpen') {
                // 简单的卷积锐化
                const kernel = [
                    0, -1,  0,
                   -1,  5, -1,
                    0, -1,  0
                ];
                const oldData = new Uint8ClampedArray(data);
                 
                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        const px = (y * width + x) * 4;
                        let r = 0, g = 0, b = 0;
                         
                        for (let ky = -1; ky <= 1; ky++) {
                            for (let kx = -1; kx <= 1; kx++) {
                                const kIdx = (ky + 1) * 3 + (kx + 1);
                                const pIdx = ((y + ky) * width + (x + kx)) * 4;
                                r += oldData[pIdx] * kernel[kIdx];
                                g += oldData[pIdx + 1] * kernel[kIdx];
                                b += oldData[pIdx + 2] * kernel[kIdx];
                            }
                        }
                        data[px] = Math.min(255, Math.max(0, r));
                        data[px+1] = Math.min(255, Math.max(0, g));
                        data[px+2] = Math.min(255, Math.max(0, b));
                    }
                }
            }
             
            ctx.putImageData(imageData, 0, 0);
            return canvas.toDataURL('image/jpeg', 0.95);
        };
 
        const processSignatureCrop = (sourceImage, cropRect) => {
            // 透明背景 Canvas (给用户看)
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = cropRect.width;
            canvas.height = cropRect.height;
 
            // 绘制原始选区
            ctx.drawImage(sourceImage, cropRect.x, cropRect.y, cropRect.width, cropRect.height, 0, 0, cropRect.width, cropRect.height);
             
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const width = canvas.width;
            const height = canvas.height;
             
            // 步骤 1：基于亮度计算初始 Alpha 通道
            // 使用 Float32Array 存储 Alpha 以便进行平滑处理
            const alphaChannel = new Float32Array(width * height);
 
            for (let i = 0; i < width * height; i++) {
                const r = data[i*4];
                const g = data[i*4+1];
                const b = data[i*4+2];
                 
                // 计算亮度
                const luminance = 0.299 * r + 0.587 * g + 0.114 * b;
                 
                // 阈值定义
                const whitePoint = 230; 
                const blackPoint = 100;
                 
                let a = 0;
                if (luminance >= whitePoint) {
                    a = 0;
                } else if (luminance <= blackPoint) {
                    a = 255;
                } else {
                    a = 255 * (1 - (luminance - blackPoint) / (whitePoint - blackPoint));
                }
                alphaChannel[i] = a;
            }
 
            // 步骤 2：Alpha 通道羽化 (Feathering)
            // 模拟 PS 的羽化效果：对 Alpha 通道进行简单的 3x3 均值模糊，重复两次以逼近高斯模糊
            const blurAlpha = (srcAlpha, w, h) => {
                const dstAlpha = new Float32Array(srcAlpha.length);
                for (let y = 0; y < h; y++) {
                    for (let x = 0; x < w; x++) {
                        let sum = 0;
                        let count = 0;
                        // 3x3 卷积核
                        for (let ky = -1; ky <= 1; ky++) {
                            for (let kx = -1; kx <= 1; kx++) {
                                const nx = x + kx;
                                const ny = y + ky;
                                if (nx >= 0 && nx < w && ny >= 0 && ny < h) {
                                    sum += srcAlpha[ny * w + nx];
                                    count++;
                                }
                            }
                        }
                        dstAlpha[y * w + x] = sum / count;
                    }
                }
                return dstAlpha;
            };
 
            // 执行两次模糊，使得边缘更柔和 (相当于 1-2px 羽化)
            let featheredAlpha = blurAlpha(alphaChannel, width, height);
            featheredAlpha = blurAlpha(featheredAlpha, width, height);
 
            // 步骤 3：回填数据与色彩净化 (Decontaminate Colors)
            for (let i = 0; i < width * height; i++) {
                const idx = i * 4;
                const r = data[idx];
                const g = data[idx+1];
                const b = data[idx+2];
                 
                const a = featheredAlpha[i];
                 
                // 设置新的 Alpha
                data[idx + 3] = a;
 
                // 色彩净化核心逻辑：
                // 如果像素处于半透明状态（边缘），且原色较亮（可能是纸张白边），强制压暗。
                // 模拟墨水渗透效果，让边缘呈现“淡淡的黑色”而不是“淡淡的白色”。
                if (a > 0 && a < 250) {
                     // 边缘区域：强制压暗 RGB
                     data[idx] = Math.min(r, 60);
                     data[idx+1] = Math.min(g, 60);
                     data[idx+2] = Math.min(b, 60);
                } else if (a >= 250) {
                     // 核心区域：轻微增强对比度
                     data[idx] = Math.max(0, r - 30);
                     data[idx+1] = Math.max(0, g - 30);
                     data[idx+2] = Math.max(0, b - 30);
                }
            }
 
            ctx.putImageData(imageData, 0, 0);
            const blobUrl = canvas.toDataURL('image/png');
 
            // 白底 Canvas (给AI看，AI识别需要完整的笔画结构，不要透明度)
            const aiCanvas = document.createElement('canvas');
            aiCanvas.width = cropRect.width;
            aiCanvas.height = cropRect.height;
            const aiCtx = aiCanvas.getContext('2d');
            aiCtx.fillStyle = '#FFFFFF';
            aiCtx.fillRect(0, 0, aiCanvas.width, aiCanvas.height);
            // 重新绘制原始像素
            aiCtx.drawImage(sourceImage, cropRect.x, cropRect.y, cropRect.width, cropRect.height, 0, 0, cropRect.width, cropRect.height);
             
            // AI 识别增强
            const aiImageData = aiCtx.getImageData(0, 0, aiCanvas.width, aiCanvas.height);
            const aiData = aiImageData.data;
            for (let i = 0; i < aiData.length; i += 4) {
                 const gray = 0.299 * aiData[i] + 0.587 * aiData[i+1] + 0.114 * aiData[i+2];
                 // 简单的对比度拉伸
                 if (gray > 200) {
                     aiData[i] = aiData[i+1] = aiData[i+2] = 255;
                 } else {
                     aiData[i] = aiData[i+1] = aiData[i+2] = Math.max(0, gray - 30);
                 }
            }
            aiCtx.putImageData(aiImageData, 0, 0);
 
            const aiDataURL = aiCanvas.toDataURL('image/jpeg', 0.95);
            const base64Data = aiDataURL.replace(/^data:image\/jpeg;base64,/, '');
 
            return { blobUrl, base64Data };
        };
 
        // --- 3. AI 服务函数 (AI Service) ---
        const PROVIDERS = {
            zhipu: {
                name: "智谱AI (GLM-4V-Flash)",
                endpoint: "https://open.bigmodel.cn/api/paas/v4/chat/completions",
                model: "glm-4v-flash",
                headers: (apiKey) => ({ "Authorization": `Bearer ${apiKey}`, "Content-Type": "application/json" })
            },
            aliyun: {
                name: "阿里云 (Qwen-VL-Max)",
                endpoint: "https://dashscope.aliyuncs.com/compatible-mode/v1/chat/completions",
                model: "qwen-vl-max",
                headers: (apiKey) => ({ "Authorization": `Bearer ${apiKey}`, "Content-Type": "application/json" })
            }
        };
 
        const recognizeSignature = async (base64Image, apiKey, provider = 'zhipu') => {
            if (!apiKey) return "请配置API Key";
            const currentProvider = PROVIDERS[provider];
            if (!currentProvider) return "无效的服务商";
 
            const systemPrompt = `你是一个严格的OCR工具。
    规则：
    1. 只输出图中的文字，严禁包含“图片中是”、“写着”等任何解释性前缀。
    2. 严禁标点符号。
    3. 如果是人名，仅输出名字。
    4. 无法识别返回“未识别”。`;
 
            try {
                const response = await fetch(currentProvider.endpoint, {
                    method: "POST",
                    headers: currentProvider.headers(apiKey),
                    body: JSON.stringify({
                        model: currentProvider.model,
                        messages: [
                            { role: "system", content: systemPrompt },
                            { role: "user", content: [
                                { type: "image_url", image_url: { url: `data:image/jpeg;base64,${base64Image}` } },
                                { type: "text", text: "念出图里的字，只输出内容，不要废话。" }
                            ]}
                        ],
                        temperature: 0.01,
                        max_tokens: 50
                    })
                });
 
                if (!response.ok) {
                    const status = response.status;
                    if(status === 401) return "Key无效";
                    if(status === 429) return "请求太频繁";
                    return `请求失败 (${status})`;
                }
 
                const data = await response.json();
                let content = data.choices?.[0]?.message?.content || "未识别";
                 
                content = content.trim();
                // 暴力清洗所有可能的“啰嗦”前缀
                content = content.replace(/^(图片|内容|文字|识别结果).{0,10}[:：是]\s*/, '')
                                 .replace(/^.*?(写|显示|为|是|：|:)\s*/, '')
                                 .replace(/[。\.!！,，]$/g, '');
 
                return content || "未识别";
            } catch (error) {
                console.error(error);
                return "网络错误(可能跨域)";
            }
        };
 
        // --- 4. 主应用程序 (Main App) ---
        function App() {
            const [originalFileStr, setOriginalFileStr] = useState(null); // 备份原始文件数据
            const [sourceImage, setSourceImage] = useState(null); // 当前显示的图片（可能已被处理）
            const [imageObj, setImageObj] = useState(null);
            const [isProcessingImg, setIsProcessingImg] = useState(false);
             
            const [signatures, setSignatures] = useState([]);
             
            // Settings
            const [isSettingsOpen, setIsSettingsOpen] = useState(false);
            const [provider, setProvider] = useState('zhipu');
            const [zhipuKey, setZhipuKey] = useState('');
            const [aliyunKey, setAliyunKey] = useState('');
             
            // Temp Settings
            const [tempProvider, setTempProvider] = useState('zhipu');
            const [tempZhipuKey, setTempZhipuKey] = useState('');
            const [tempAliyunKey, setTempAliyunKey] = useState('');
 
            // Canvas Logic
            const [isDrawing, setIsDrawing] = useState(false);
            const [isPanning, setIsPanning] = useState(false);
            const [startPoint, setStartPoint] = useState(null);
            const [panStart, setPanStart] = useState(null);
            const [currentRect, setCurrentRect] = useState(null);
            const [undoStack, setUndoStack] = useState([]);
 
            const [scale, setScale] = useState(1);
            const [pan, setPan] = useState({ x: 0, y: 0 });
            const [isSpacePressed, setIsSpacePressed] = useState(false);
 
            const [sidebarWidth, setSidebarWidth] = useState(400);
            const [isResizingSidebar, setIsResizingSidebar] = useState(false);
 
            // Preview Modal
            const [previewSig, setPreviewSig] = useState(null);
            const [pScale, setPScale] = useState(1);
            const [pPan, setPPan] = useState({ x: 0, y: 0 });
            const [isPPanning, setIsPPanning] = useState(false);
            const [pPanStart, setPPanStart] = useState(null);
             
            const viewportRef = useRef(null);
            const contentRef = useRef(null);
            const previewRef = useRef(null);
 
            // Init
            useEffect(() => {
                const storedProvider = localStorage.getItem('ai_provider');
                const storedZhipu = localStorage.getItem('api_key_zhipu');
                const storedAliyun = localStorage.getItem('api_key_aliyun');
                if (storedProvider) setProvider(storedProvider);
                if (storedZhipu) setZhipuKey(storedZhipu);
                if (storedAliyun) setAliyunKey(storedAliyun);
            }, []);
 
            const openSettings = () => {
                setTempProvider(provider);
                setTempZhipuKey(zhipuKey);
                setTempAliyunKey(aliyunKey);
                setIsSettingsOpen(true);
            };
 
            const saveSettings = () => {
                localStorage.setItem('ai_provider', tempProvider);
                localStorage.setItem('api_key_zhipu', tempZhipuKey.trim());
                localStorage.setItem('api_key_aliyun', tempAliyunKey.trim());
                setProvider(tempProvider);
                setZhipuKey(tempZhipuKey.trim());
                setAliyunKey(tempAliyunKey.trim());
                setIsSettingsOpen(false);
            };
 
            const getActiveKey = () => provider === 'zhipu' ? zhipuKey : aliyunKey;
 
            // Load Image
            useEffect(() => {
                if (sourceImage) {
                    loadImage(sourceImage).then(img => {
                        setImageObj(img);
                        // 如果是刚上传（没有imageObj），重置缩放
                        if (!imageObj) {
                            setScale(1);
                            setPan({ x: 0, y: 0 });
                        }
                    });
                }
            }, [sourceImage]);
 
            const handleFileUpload = (e) => {
                const file = e.target.files?.[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        setOriginalFileStr(event.target.result);
                        setSourceImage(event.target.result);
                        setSignatures([]);
                        setUndoStack([]);
                    };
                    reader.readAsDataURL(file);
                }
            };
 
            const handleApplyFilter = async (type) => {
                if (!imageObj) return;
                setIsProcessingImg(true);
                 
                try {
                    // 如果是还原，直接使用 originalFileStr
                    if (type === 'reset') {
                        if (originalFileStr) {
                            setSourceImage(originalFileStr);
                        }
                    } else {
                        // 应用滤镜
                        const newSrc = await applyImageFilters(imageObj, type);
                        setSourceImage(newSrc);
                    }
                } catch(e) {
                    console.error("Image processing failed", e);
                } finally {
                    setIsProcessingImg(false);
                }
            };
 
            const handleColorChange = async (id, color) => {
                const sig = signatures.find(s => s.id === id);
                if (!sig) return;
                 
                // 简单的防抖或加载状态可以加在这里，但对于小图通常很快
                const newUrl = await applySignatureColor(sig.previewUrl, color);
                 
                setSignatures(prev => prev.map(s => s.id === id ? { ...s, previewUrl: newUrl } : s));
            };
 
            const handleUndo = () => {
                if (undoStack.length > 0) {
                    const last = undoStack[undoStack.length - 1];
                    setSignatures(prev => [...prev, last]);
                    setUndoStack(prev => prev.slice(0, -1));
                } else if (signatures.length > 0) {
                    const last = signatures[signatures.length - 1];
                    setSignatures(prev => prev.slice(0, -1));
                }
            };
 
            const handleRemoveSignature = (id) => {
                const sig = signatures.find(s => s.id === id);
                if (sig) {
                    setUndoStack(prev => [...prev, sig]);
                    setSignatures(prev => prev.filter(s => s.id !== id));
                }
            };
 
            const handleDownload = (sig) => {
                if (!sig.previewUrl) return;
                const link = document.createElement('a');
                link.href = sig.previewUrl;
                link.download = `${sig.fileName || 'signature'}.png`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            };
 
            const handleDownloadAllZip = async () => {
                if (!window.JSZip) return alert("JSZip 未加载");
                const zip = new JSZip();
                const folder = zip.folder("signatures");
                let hasFiles = false;
                 
                signatures.forEach(sig => {
                    if (sig.previewUrl && sig.status !== 'error') {
                        let name = sig.fileName.trim() || `signature_${sig.id}`;
                        name = name.replace(/[<>:"/\\|?*]+/g, '_');
                        const base64Data = sig.previewUrl.replace(/^data:image\/(png|jpg);base64,/, "");
                        folder.file(`${name}.png`, base64Data, {base64: true});
                        hasFiles = true;
                    }
                });
 
                if (hasFiles) {
                    const content = await zip.generateAsync({type:"blob"});
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(content);
                    link.download = `signatures_${new Date().toISOString().slice(0,10)}.zip`;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                }
            };
 
            // Canvas & Interaction
            const getContentCoordinates = (e) => {
                const rect = viewportRef.current.getBoundingClientRect();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                return {
                    x: (clientX - rect.left - pan.x) / scale,
                    y: (clientY - rect.top - pan.y) / scale
                };
            };
 
            const handleWheel = (e) => {
                if (!viewportRef.current) return;
                e.preventDefault();
                const delta = -e.deltaY * 0.001;
                const newScale = Math.min(5, Math.max(0.1, scale + delta));
                const rect = viewportRef.current.getBoundingClientRect();
                const cursorX = e.clientX - rect.left;
                const cursorY = e.clientY - rect.top;
                const contentX = (cursorX - pan.x) / scale;
                const contentY = (cursorY - pan.y) / scale;
                setPan({
                    x: cursorX - contentX * newScale,
                    y: cursorY - contentY * newScale
                });
                setScale(newScale);
            };
 
            const handleMouseDown = (e) => {
                if (e.target.closest('button') || e.target.closest('input')) return;
                if (!viewportRef.current || !sourceImage) return;
 
                const isMiddle = e.button === 1;
                if (isSpacePressed || isMiddle) {
                    e.preventDefault();
                    setIsPanning(true);
                    setPanStart({ x: e.clientX, y: e.clientY });
                } else {
                    if (e.button !== 0) return;
                    const point = getContentCoordinates(e);
                    setIsDrawing(true);
                    setStartPoint(point);
                    setCurrentRect({ x: point.x, y: point.y, width: 0, height: 0 });
                }
            };
 
            const handleMouseMove = (e) => {
                if (!viewportRef.current) return;
                if (isPanning && panStart) {
                    e.preventDefault();
                    const dx = e.clientX - panStart.x;
                    const dy = e.clientY - panStart.y;
                    setPan(prev => ({ x: prev.x + dx, y: prev.y + dy }));
                    setPanStart({ x: e.clientX, y: e.clientY });
                    return;
                }
                if (isDrawing && startPoint) {
                    const current = getContentCoordinates(e);
                    const w = current.x - startPoint.x;
                    const h = current.y - startPoint.y;
                    setCurrentRect({
                        x: w > 0 ? startPoint.x : current.x,
                        y: h > 0 ? startPoint.y : current.y,
                        width: Math.abs(w),
                        height: Math.abs(h)
                    });
                }
            };
 
            const handleMouseUp = async () => {
                if (isPanning) {
                    setIsPanning(false);
                    setPanStart(null);
                    return;
                }
                if (!isDrawing || !currentRect || !imageObj || !contentRef.current) {
                    setIsDrawing(false); setCurrentRect(null); return;
                }
                if (currentRect.width < 5 || currentRect.height < 5) {
                    setIsDrawing(false); setCurrentRect(null); return;
                }
 
                const displayedRect = currentRect;
                const currentApiKey = getActiveKey();
                const imgElement = contentRef.current.querySelector('img');
                const ratioX = imageObj.naturalWidth / imgElement.offsetWidth;
                const ratioY = imageObj.naturalHeight / imgElement.offsetHeight;
                 
                const actualCropRect = {
                    x: displayedRect.x * ratioX,
                    y: displayedRect.y * ratioY,
                    width: displayedRect.width * ratioX,
                    height: displayedRect.height * ratioY
                };
 
                const newId = Date.now().toString();
                const newSig = {
                    id: newId,
                    originalRect: displayedRect,
                    previewUrl: '',
                    fileName: '识别中...',
                    status: 'processing'
                };
                setSignatures(prev => [...prev, newSig]);
                setIsDrawing(false); setCurrentRect(null);
 
                try {
                    // 使用当前显示的图片（可能是处理过的）进行抠图
                    const { blobUrl, base64Data } = processSignatureCrop(imageObj, actualCropRect);
                    setSignatures(prev => prev.map(s => s.id === newId ? { ...s, previewUrl: blobUrl } : s));
 
                    if (!currentApiKey) {
                        setSignatures(prev => prev.map(s => s.id === newId ? { ...s, fileName: "未配置Key", status: 'error' } : s));
                        setIsSettingsOpen(true);
                        return;
                    }
 
                    const name = await recognizeSignature(base64Data, currentApiKey, provider);
                    setSignatures(prev => prev.map(s => s.id === newId ? { 
                        ...s, fileName: name, status: name.includes('失败') ? 'error' : 'success' 
                    } : s));
 
                } catch (e) {
                    console.error(e);
                }
            };
 
            // Keyboard
            useEffect(() => {
                const down = (e) => {
                    if (e.code === 'Space' && !e.repeat && !isSettingsOpen) setIsSpacePressed(true);
                    if ((e.ctrlKey || e.metaKey) && e.key === 'z') handleUndo();
                    if (e.key === 'Escape' && previewSig) setPreviewSig(null);
                };
                const up = (e) => {
                    if (e.code === 'Space') { setIsSpacePressed(false); setIsPanning(false); }
                };
                window.addEventListener('keydown', down);
                window.addEventListener('keyup', up);
                return () => {
                    window.removeEventListener('keydown', down);
                    window.removeEventListener('keyup', up);
                };
            }, [signatures, isSettingsOpen, undoStack, previewSig]);
 
            // Preview logic
            const handlePreviewWheel = (e) => {
                e.preventDefault();
                setPScale(Math.min(10, Math.max(0.1, pScale + -e.deltaY * 0.001)));
            };
            const handlePreviewMouseMove = (e) => {
                if (isPPanning && pPanStart) {
                    setPPan(prev => ({ x: prev.x + e.clientX - pPanStart.x, y: prev.y + e.clientY - pPanStart.y }));
                    setPPanStart({ x: e.clientX, y: e.clientY });
                }
            };
 
            // Resize sidebar
            const startResizing = (e) => {
                e.preventDefault();
                setIsResizingSidebar(true);
                const startX = e.clientX;
                const startW = sidebarWidth;
                const move = (ev) => setSidebarWidth(Math.max(320, Math.min(startW + (ev.clientX - startX), 800)));
                const up = () => {
                    setIsResizingSidebar(false);
                    document.removeEventListener('mousemove', move);
                    document.removeEventListener('mouseup', up);
                };
                document.addEventListener('mousemove', move);
                document.addEventListener('mouseup', up);
            };
 
            return (
                <div className="flex h-screen text-[#1d1d1f] overflow-hidden select-none font-sans relative">
                     
                    {/* Sidebar */}
                    <div className="relative bg-white/20 backdrop-blur-xl border-r border-white/30 flex flex-col shadow-xl z-20" style={{ width: sidebarWidth }}>
                        <div className="px-6 py-8 flex-shrink-0">
                            <h1 className="text-xl font-bold tracking-tight flex items-center gap-3">
                                <div className="w-10 h-10 bg-gradient-to-br from-indigo-500 to-purple-600 rounded-2xl flex items-center justify-center shadow-lg text-white">
                                    <SparklesIcon className="w-5 h-5" />
                                </div>
                                <span className="truncate">智能签名提取</span>
                            </h1>
                            <div className="flex items-center justify-between mt-6 px-1">
                                <div className="flex items-center gap-2 px-3 py-1.5 bg-white/40 rounded-full border border-white/20 shadow-sm">
                                    <div className={`w-2 h-2 rounded-full ${provider === 'zhipu' ? 'bg-green-500' : 'bg-orange-500'}`}></div>
                                    <p className="text-[11px] font-semibold text-slate-600">{provider === 'zhipu' ? '智谱 GLM-4' : '阿里云 Qwen'}</p>
                                </div>
                                <div className="flex gap-2">
                                    <button onClick={handleUndo} className="w-8 h-8 flex items-center justify-center rounded-full bg-white/40 border border-white/30 hover:bg-white/60 transition-all active:scale-95"><UndoIcon className="w-4 h-4" /></button>
                                    <button onClick={openSettings} className="w-8 h-8 flex items-center justify-center rounded-full bg-white/40 border border-white/30 hover:bg-white/60 transition-all active:scale-95"><SettingsIcon className="w-4 h-4" /></button>
                                </div>
                            </div>
                        </div>
 
                        <div className="flex-1 overflow-y-auto px-6 pb-6 no-scrollbar">
                            {signatures.length === 0 ? (
                                <div className="text-center py-32 text-slate-500 flex flex-col items-center">
                                    <div className="w-20 h-20 bg-white/30 border border-white/20 rounded-[2rem] flex items-center justify-center mb-6"><ScissorIcon className="w-8 h-8 opacity-40" /></div>
                                    <p className="text-base font-medium">暂无签名</p>
                                    <p className="text-xs mt-2 opacity-60">请在右侧画布上框选</p>
                                </div>
                            ) : (
                                <div className="grid grid-cols-2 gap-4 pb-4">
                                    {[...signatures].reverse().map(sig => (
                                        <div key={sig.id} className="bg-white/40 backdrop-blur-md rounded-[28px] p-4 shadow-sm border border-white/40 hover:bg-white/60 hover:shadow-lg transition-all relative group flex flex-col">
                                            <button onClick={() => handleRemoveSignature(sig.id)} className="absolute -top-1 -right-1 z-10 bg-white text-slate-400 hover:text-rose-500 rounded-full p-1.5 shadow-md opacity-0 group-hover:opacity-100 transition-all scale-90 group-hover:scale-100"><XIcon className="w-3 h-3" /></button>
                                            <div onClick={() => { setPreviewSig(sig); setPScale(1); setPPan({x:0,y:0}); }} className="aspect-[4/3] bg-white/50 rounded-[20px] flex items-center justify-center mb-3 overflow-hidden cursor-zoom-in relative group/image border border-white/30">
                                                {sig.previewUrl && <img src={sig.previewUrl} className="max-h-full max-w-full object-contain p-2 transition-transform duration-300 group-hover/image:scale-110" />}
                                                <div className="absolute inset-0 bg-black/5 opacity-0 group-hover/image:opacity-100 transition-opacity flex items-center justify-center"><div className="bg-white/80 backdrop-blur-sm p-2 rounded-full"><MaximizeIcon className="w-4 h-4" /></div></div>
                                            </div>
                                            <div className="px-1 mb-2 flex-1 min-h-[24px] flex items-center">
                                                {sig.status === 'processing' ? (
                                                    <div className="flex items-center gap-2 text-[#0071e3] text-xs font-semibold px-2 py-1 bg-blue-50/50 rounded-lg w-full"><LoaderIcon className="w-3 h-3" /><span>识别中...</span></div>
                                                ) : (
                                                    <input type="text" defaultValue={sig.fileName} className="w-full bg-transparent border-none p-0 text-sm font-bold focus:outline-none rounded px-1 -ml-1 truncate text-slate-800" onBlur={(e) => { const v = e.target.value; setSignatures(p => p.map(s => s.id === sig.id ? {...s, fileName: v} : s)); }} />
                                                )}
                                            </div>
                                             
                                            {/* Color Palette */}
                                            {sig.status !== 'processing' && sig.status !== 'error' && (
                                                <div className="flex items-center gap-2 mb-3 px-1">
                                                    <button onClick={() => handleColorChange(sig.id, '#000000')} className="w-5 h-5 rounded-full bg-black border border-white/20 shadow-sm hover:scale-110 transition-transform active:scale-90" title="黑色"></button>
                                                    <button onClick={() => handleColorChange(sig.id, '#ef4444')} className="w-5 h-5 rounded-full bg-red-500 border border-white/20 shadow-sm hover:scale-110 transition-transform active:scale-90" title="红色"></button>
                                                    <button onClick={() => handleColorChange(sig.id, '#3b82f6')} className="w-5 h-5 rounded-full bg-blue-500 border border-white/20 shadow-sm hover:scale-110 transition-transform active:scale-90" title="蓝色"></button>
                                                    <label className="w-5 h-5 rounded-full bg-gradient-to-br from-yellow-300 via-pink-400 to-indigo-400 border border-white/20 shadow-sm hover:scale-110 transition-transform active:scale-90 cursor-pointer flex items-center justify-center relative">
                                                        <input type="color" className="absolute inset-0 opacity-0 cursor-pointer w-full h-full" onChange={(e) => handleColorChange(sig.id, e.target.value)} />
                                                    </label>
                                                </div>
                                            )}
 
                                            <button onClick={() => handleDownload(sig)} className="mt-auto w-full bg-[#0071e3] hover:bg-[#005bb5] text-white text-xs font-semibold py-2.5 rounded-2xl shadow-lg active:scale-95 transition-all flex items-center justify-center gap-2"><DownloadIcon className="w-3.5 h-3.5" />下载</button>
                                        </div>
                                    ))}
                                </div>
                            )}
                        </div>
 
                        <div className="p-6 bg-white/30 backdrop-blur-xl border-t border-white/20 flex-shrink-0 z-20">
                            {signatures.length === 0 ? (
                                <label className="flex items-center justify-center gap-3 w-full bg-[#FF9F0A] hover:bg-[#F09000] text-white py-4 rounded-[20px] cursor-pointer transition-all shadow-xl active:scale-[0.98] group">
                                    <div className="bg-white/20 p-1 rounded-full"><UploadIcon className="w-4 h-4" /></div>
                                    <span className="text-sm font-bold tracking-wide">上传图片</span>
                                    <input type="file" accept="image/*" onChange={handleFileUpload} className="hidden" />
                                </label>
                            ) : (
                                <div className="flex flex-col gap-3">
                                    <button onClick={handleDownloadAllZip} className="w-full flex items-center justify-center gap-2 bg-[#1d1d1f] hover:bg-black text-white py-3.5 rounded-[20px] shadow-xl active:scale-[0.98] transition-all"><DownloadIcon className="w-4 h-4" /><span className="text-sm font-bold">批量导出 ZIP</span></button>
                                    <label className="w-full flex items-center justify-center gap-2 text-slate-500 hover:text-[#0071e3] hover:bg-white/40 py-2.5 rounded-[16px] cursor-pointer transition-all text-xs font-semibold">更换图片<input type="file" accept="image/*" onChange={handleFileUpload} className="hidden" /></label>
                                </div>
                            )}
                        </div>
                        <div className="absolute right-0 top-0 bottom-0 w-1.5 cursor-col-resize hover:bg-[#0071e3]/50 z-30" onMouseDown={startResizing} />
                    </div>
 
                    {/* Workspace */}
                    <div className="flex-1 relative flex flex-col">
                        <div className="absolute top-8 left-1/2 -translate-x-1/2 bg-white/70 backdrop-blur-2xl shadow-xl rounded-full px-5 py-2 flex items-center gap-4 z-20 border border-white/40">
                             <div className="flex items-center gap-1">
                                 <button onClick={() => { if(viewportRef.current) { const s = Math.max(0.1, scale/1.2); setScale(s); } }} className="w-8 h-8 flex items-center justify-center hover:bg-black/5 rounded-full"><ZoomOutIcon className="w-4 h-4" /></button>
                                 <span className="text-xs font-bold font-mono w-12 text-center text-slate-500">{Math.round(scale * 100)}%</span>
                                 <button onClick={() => { if(viewportRef.current) { const s = Math.min(5, scale*1.2); setScale(s); } }} className="w-8 h-8 flex items-center justify-center hover:bg-black/5 rounded-full"><ZoomInIcon className="w-4 h-4" /></button>
                             </div>
                             <div className="w-px h-4 bg-slate-200"></div>
                             <button onClick={() => { setScale(1); setPan({x:0,y:0}); }} className="w-8 h-8 flex items-center justify-center hover:bg-black/5 rounded-full"><ResetIcon className="w-4 h-4" /></button>
                             <div className={`flex items-center gap-2 text-xs px-3 py-1.5 rounded-full font-bold transition-all ${isPanning || isSpacePressed ? 'bg-[#0071e3] text-white' : 'bg-slate-100 text-slate-500'}`}><HandIcon className="w-3.5 h-3.5" /><span>平移</span></div>
                        </div>
 
                        {/* Image Enhancement Toolbar (Bottom) */}
                        {sourceImage && (
                            <div className="absolute bottom-8 left-1/2 -translate-x-1/2 bg-white/80 backdrop-blur-2xl shadow-2xl rounded-2xl p-2 flex items-center gap-2 z-20 border border-white/50 animate-fade-in">
                                <button onClick={() => handleApplyFilter('bleach')} disabled={isProcessingImg} className="flex flex-col items-center justify-center w-16 h-14 rounded-xl hover:bg-blue-50 text-slate-600 hover:text-[#0071e3] transition-all disabled:opacity-50">
                                    <div className="bg-white shadow-sm border border-slate-100 p-1.5 rounded-lg mb-1"><WandIcon className="w-4 h-4" /></div>
                                    <span className="text-[10px] font-bold">智能漂白</span>
                                </button>
                                <button onClick={() => handleApplyFilter('sharpen')} disabled={isProcessingImg} className="flex flex-col items-center justify-center w-16 h-14 rounded-xl hover:bg-blue-50 text-slate-600 hover:text-[#0071e3] transition-all disabled:opacity-50">
                                    <div className="bg-white shadow-sm border border-slate-100 p-1.5 rounded-lg mb-1"><EyeIcon className="w-4 h-4" /></div>
                                    <span className="text-[10px] font-bold">高清锐化</span>
                                </button>
                                <div className="w-px h-8 bg-slate-300 mx-1"></div>
                                <button onClick={() => handleApplyFilter('reset')} disabled={isProcessingImg} className="flex flex-col items-center justify-center w-16 h-14 rounded-xl hover:bg-red-50 text-slate-600 hover:text-red-500 transition-all disabled:opacity-50">
                                     <div className="bg-white shadow-sm border border-slate-100 p-1.5 rounded-lg mb-1"><UndoIcon className="w-4 h-4" /></div>
                                     <span className="text-[10px] font-bold">还原原图</span>
                                </button>
                            </div>
                        )}
 
                        <div ref={viewportRef} className="flex-1 w-full h-full relative overflow-hidden" onMouseDown={handleMouseDown} onMouseMove={handleMouseMove} onMouseUp={handleMouseUp} onMouseLeave={handleMouseUp} onWheel={handleWheel} style={{ cursor: isPanning ? 'grabbing' : (isSpacePressed ? 'grab' : 'crosshair') }}>
                            {!sourceImage && (
                                <div className="absolute inset-0 flex flex-col items-center justify-center pointer-events-none">
                                    <div className="w-28 h-28 bg-white/40 backdrop-blur-sm rounded-[3rem] shadow-2xl flex items-center justify-center mb-8 border border-white/40 animate-pulse"><UploadIcon className="w-10 h-10 text-[#0071e3]" /></div>
                                    <p className="text-2xl font-bold text-slate-800">请先上传一张图片</p>
                                    <p className="text-sm text-slate-500 mt-3 font-medium bg-white/30 px-4 py-1.5 rounded-full border border-white/20">支持拖拽平移 &#8226; 滚轮缩放 &#8226; AI 自动识别</p>
                                </div>
                            )}
                            {sourceImage && (
                                <div ref={contentRef} className="absolute origin-top-left shadow-2xl rounded-xl overflow-hidden ring-4 ring-white/50" style={{ transform: `translate(${pan.x}px, ${pan.y}px) scale(${scale})` }}>
                                    <img src={sourceImage} draggable={false} className="max-w-none block select-none pointer-events-none transition-all duration-300" style={{ filter: isProcessingImg ? 'blur(4px)' : 'none' }} />
                                    {signatures.map(sig => (
                                        <div key={sig.id} className="absolute border-2 border-[#0071e3] bg-[#0071e3]/10 rounded-lg group" style={{ left: sig.originalRect.x, top: sig.originalRect.y, width: sig.originalRect.width, height: sig.originalRect.height }}>
                                            <button className="absolute -top-3 -right-3 bg-white text-rose-500 rounded-full p-1.5 shadow-lg opacity-0 group-hover:opacity-100 transition-all hover:scale-110 z-10" onClick={(e) => { e.stopPropagation(); handleRemoveSignature(sig.id); }}><XIcon className="w-3.5 h-3.5" /></button>
                                            <div className="absolute -bottom-10 left-1/2 -translate-x-1/2 bg-white/90 backdrop-blur-md text-slate-800 text-xs font-bold px-3 py-1.5 rounded-full shadow-xl whitespace-nowrap opacity-0 group-hover:opacity-100 transition-all pointer-events-none border border-white/50 z-20">{sig.fileName}</div>
                                        </div>
                                    ))}
                                    {isDrawing && currentRect && (
                                        <div className="absolute border-2 border-[#0071e3] bg-[#0071e3]/20 rounded-lg" style={{ left: currentRect.x, top: currentRect.y, width: currentRect.width, height: currentRect.height }}>
                                            <div className="absolute -top-10 left-0 bg-[#0071e3] text-white text-xs font-bold px-3 py-1.5 rounded-full shadow-lg flex items-center gap-1.5"><ScissorIcon className="w-3.5 h-3.5" /><span>识别区域</span></div>
                                        </div>
                                    )}
                                </div>
                            )}
                            {isProcessingImg && (
                                <div className="absolute inset-0 flex items-center justify-center z-50">
                                    <div className="bg-black/70 backdrop-blur-md text-white px-6 py-3 rounded-full flex items-center gap-3 shadow-2xl">
                                        <LoaderIcon className="w-5 h-5" />
                                        <span className="text-sm font-bold">图像处理中...</span>
                                    </div>
                                </div>
                            )}
                        </div>
                    </div>
 
                    {/* Preview Modal */}
                    {previewSig && (
                        <div className="fixed inset-0 z-50 flex items-center justify-center bg-[#1d1d1f]/60 backdrop-blur-xl animate-in fade-in duration-200">
                           <div className="absolute inset-0" onMouseDown={(e)=>{setIsPPanning(true); setPPanStart({x:e.clientX, y:e.clientY})}} onMouseMove={handlePreviewMouseMove} onMouseUp={()=>{setIsPPanning(false);setPPanStart(null)}} onMouseLeave={()=>{setIsPPanning(false);setPPanStart(null)}} onWheel={handlePreviewWheel}>
                              <div ref={previewRef} style={{ transform: `translate(${pPan.x}px, ${pPan.y}px) scale(${pScale})`, cursor: isPPanning ? 'grabbing' : 'grab', transition: isPPanning ? 'none' : 'transform 0.1s' }} className="flex items-center justify-center h-full">
                                  <div className="bg-[url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAMUlEQVQ4T2NkYGAQYcAP3uCTZhw1gGGYhAGBZIA/nYDCgBDAm9BGDWAAJyRCgLaBCAAgXwixzAS0pgAAAABJRU5ErkJggg==')] bg-white shadow-2xl rounded-lg overflow-hidden">
                                      <img src={previewSig.previewUrl} className="max-w-none pointer-events-none select-none" />
                                  </div>
                              </div>
                           </div>
                           <div className="absolute bottom-12 left-1/2 -translate-x-1/2 bg-black/80 backdrop-blur-2xl rounded-[2rem] px-8 py-4 flex items-center gap-8 shadow-2xl z-50">
                              <div className="flex items-center gap-2">
                                 <button onClick={()=>setPScale(Math.max(0.1, pScale/1.2))} className="p-2 hover:bg-white/10 rounded-full text-white/70"><ZoomOutIcon className="w-5 h-5" /></button>
                                 <span className="text-white font-mono text-sm w-12 text-center font-bold">{Math.round(pScale*100)}%</span>
                                 <button onClick={()=>setPScale(Math.min(10, pScale*1.2))} className="p-2 hover:bg-white/10 rounded-full text-white/70"><ZoomInIcon className="w-5 h-5" /></button>
                              </div>
                              <div className="w-px h-6 bg-white/20"></div>
                              <button onClick={()=>setPreviewSig(null)} className="p-2 hover:bg-white/10 rounded-full text-white/70 hover:text-[#ff3b30]"><XIcon className="w-5 h-5" /></button>
                           </div>
                        </div>
                    )}
 
                    {/* Settings Modal */}
                    {isSettingsOpen && (
                        <div className="fixed inset-0 bg-black/20 backdrop-blur-sm z-50 flex items-center justify-center p-4">
                            <div className="bg-white/80 backdrop-blur-2xl rounded-[32px] shadow-2xl w-full max-w-[480px] p-8 border border-white/50">
                                <h2 className="text-2xl font-bold text-slate-800 mb-6 flex items-center gap-4"><SettingsIcon className="w-6 h-6 text-slate-600" />API 配置</h2>
                                <div className="space-y-6 mb-10">
                                    <div>
                                        <label className="block text-xs font-bold text-slate-400 uppercase mb-3">AI 服务商</label>
                                        <div className="grid grid-cols-2 gap-3 p-1.5 bg-slate-100 rounded-2xl">
                                            <button onClick={() => setTempProvider('zhipu')} className={`px-4 py-3 rounded-xl text-sm font-bold transition-all ${tempProvider === 'zhipu' ? 'bg-white shadow-sm' : 'text-slate-500'}`}>智谱 AI</button>
                                            <button onClick={() => setTempProvider('aliyun')} className={`px-4 py-3 rounded-xl text-sm font-bold transition-all ${tempProvider === 'aliyun' ? 'bg-white shadow-sm' : 'text-slate-500'}`}>阿里云 Qwen</button>
                                        </div>
                                    </div>
                                    <div>
                                        <label className="block text-xs font-bold text-slate-400 uppercase mb-3">{tempProvider === 'zhipu' ? 'GLM-4V API Key' : 'Qwen-VL API Key'}</label>
                                        <input type="password" value={tempProvider === 'zhipu' ? tempZhipuKey : tempAliyunKey} onChange={(e) => tempProvider === 'zhipu' ? setTempZhipuKey(e.target.value) : setTempAliyunKey(e.target.value)} placeholder="sk-xxxxxxxx" className="w-full px-5 py-4 bg-slate-50 border-2 border-transparent rounded-2xl text-sm font-medium focus:bg-white focus:border-blue-500 outline-none" />
                                    </div>
                                </div>
                                <div className="flex justify-end gap-3 pt-6 border-t border-slate-100">
                                    <button onClick={() => setIsSettingsOpen(false)} className="px-8 py-3 text-slate-600 hover:bg-slate-100 rounded-full text-sm font-bold">取消</button>
                                    <button onClick={saveSettings} className="px-8 py-3 bg-[#0071e3] hover:bg-[#005bb5] text-white rounded-full text-sm font-bold shadow-lg">保存配置</button>
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            );
        }
 
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>